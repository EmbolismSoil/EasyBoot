驱动框架
在boards/board.c中维护一个全局board对象线性表。
在driver/driver.c中维护一个全局driver线性表。

board对象：
	1 板上资源（包含CPU） 2 设备链表 3 已经打开的硬件设备 4私有数据（比如板上资源说明）
	其中CPU是一个内嵌的子集，它有自己的片内集成外设。

	注：设备抽象是设备名和设备方法的封装。

CPU对象：
	1 片上资源（各种寄存器） 2 片内设备链表 3 已经打开的设备 4私有数据

通过board和CPU对象屏蔽底层细节，向上提供一个最小化的接口集：open write read close ioctl

原理：
	1 、上层用户首先执行board_type *get_board(type)
	获取board对象，这个函数会从全局board线性表当中获取对应type型号的板子。
	如果没有找到type型号的板子，则获取到一个名为type的空板子，用户需要自己搭建空板子，也就是添加硬件。
	想一下自己怎么往空的PCB上面悍硬件的？现在这是个板子抽象，我们可以往上添加硬件。
	
以下是添加硬件的方法：
	
添加硬件驱动的方法1：
	调用get_drivers(type)从driver线性表中获取一个对应型号的硬件驱动。
	调用driver_register(board, class, driver)进行驱动注册。(class是个枚举变量)
	这个函数将type型号的驱动注册在board板子型号下的driverclass中，名为type
	比如driver_register(board, CPU, s3c2440);

添加硬件驱动的方法2：
	使用宏DECLARE_DRIVER（_name）显示获取一个名为_name的空驱动。
	使用自己实现的open,write,read，ioctl填充驱动
	调用driver_regster注册

注：CPU做为一个特殊的板载硬件在驱动注册上并无区别，在底层实现中有细微差别


	2、添加硬件完成之后即可使用。调用int open(board, class, driver)打开设备。
	这个函数会从board中的class类链表中找出名为driver的设备，并且将其安装到board的中维护的已打开设备数组中去，并且返回数组下标，类似与文件描述符和句柄。
	3、打开设备后可以对设备进行读写。调用read(board, dd, buf, len);这个函数会从board的已打开设备数组中通过dd作为下标找到设备驱动程序，并且调用其中的read函数。write ioctl close同理


驱动注册的时机:
	1 在启动初期注册RAM
	2 在第二阶段，调用user_drv_register.c中函数注册
